using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections.Generic;

public class BarrierController : MonoBehaviour
{
    [Header("Persistence")]
    [Tooltip("Unique ID so checkpoints can restore this barrier.")]
    public string persistentID;

    private Collider2D col;
    private SpriteRenderer sr;
    private bool isActive = true;
    private string autoGeneratedID;

    public bool IsActive => isActive;

    void Awake()
    {
        col = GetComponent<Collider2D>();
        sr  = GetComponent<SpriteRenderer>();

        LoadStateFromCheckpoint();
    }

    public void ActivateBarrier(bool skipPersist = false)
    {
        isActive = true;

        if (col) col.enabled = true;
        if (sr)
            sr.enabled = true;

        if (!skipPersist)
            PersistStateToCheckpoint();
    }

    public void DeactivateBarrier(bool skipPersist = false)
    {
        if (!isActive && !skipPersist)
            return;

        isActive = false;

        if (col) col.enabled = false;

        if (sr)
        {
            if (skipPersist)
            {
                sr.enabled = false;
                Destroy(gameObject);
            }
            else
            {
                StartCoroutine(FadeOutAndDestroy());
            }
        }
        else
        {
            Destroy(gameObject);
        }

        if (!skipPersist)
            PersistStateToCheckpoint();
    }

    private System.Collections.IEnumerator FadeOutAndDestroy()
    {
        Color c = sr.color;
        for (float t = 0; t < 1f; t += Time.deltaTime)
        {
            c.a = Mathf.Lerp(1f, 0f, t);
            sr.color = c;
            yield return null;
        }
        Destroy(gameObject);
    }

    private void PersistStateToCheckpoint()
    {
        if (!CheckpointGameData.hasCheckpoint)
            return;

        if (CheckpointGameData.sceneName != SceneManager.GetActiveScene().name)
            return;

        var id = GetPersistenceKey();
        if (string.IsNullOrEmpty(id))
            return;

        CheckpointGameData.SetBarrierState(id, isActive);
    }

    private void LoadStateFromCheckpoint()
    {
        if (!CheckpointGameData.hasCheckpoint)
            return;

        if (CheckpointGameData.sceneName != SceneManager.GetActiveScene().name)
            return;

        var id = GetPersistenceKey();
        if (string.IsNullOrEmpty(id))
            return;

        foreach (var state in CheckpointGameData.barrierStates)
        {
            if (state.barrierID != id)
                continue;

            if (state.isActive)
                ActivateBarrier(true);
            else
                DeactivateBarrier(true);

            return;
        }
    }

    public string GetPersistenceKey()
    {
        if (!string.IsNullOrEmpty(persistentID))
            return persistentID;

        if (string.IsNullOrEmpty(autoGeneratedID))
            autoGeneratedID = $"{SceneManager.GetActiveScene().name}:{BuildHierarchyPath()}";

        return autoGeneratedID;
    }

    private string BuildHierarchyPath()
    {
        var segments = new List<string>();
        Transform current = transform;

        while (current != null)
        {
            segments.Add(current.name);
            current = current.parent;
        }

        segments.Reverse();
        return string.Join("/", segments);
    }
}
